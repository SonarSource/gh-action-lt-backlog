// Generated by dts-bundle-generator v9.5.1

import { DecoratorsPluginOptions } from '@babel/parser';
import * as t from '@babel/types';
import * as utils from '@jest/snapshot-utils';
import { FormattedTestResults } from '@jest/test-result';
import { Config } from '@jest/types';
import { ChildProcess } from 'child_process';
import EventEmitter from 'events';
import { CoverageMapData } from 'istanbul-lib-coverage';

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
/**
 * a LoginShell holds the shell path and arguments to
 * start an login/interactive shell
 */
export interface LoginShell {
	/** shell executable path */
	path: string;
	/** shell arguments */
	args: string[];
}
/**
 * Represents the project that the extension is running on and it's state
 */
export declare class ProjectWorkspace {
	/**
	 * The path to the root of the project's workspace
	 *
	 * @type {string}
	 */
	rootPath: string;
	/**
	 * The command to execute Jest on the command line, this is normally a file path like
	 * `node_modules/.bin/jest` but you should not make the assumption that it is always a direct
	 * file path, as in a create-react app it would look like `npm test --`.
	 *
	 * This means when launching a process, you will need to split on the first
	 * space, and then move any other args into the args of the process.
	 *
	 * @type {string}
	 */
	jestCommandLine: string;
	/**
	 * @deprecated please use `jestCommandLine` instead.
	 *
	 * @type {string?}
	 */
	get pathToJest(): string;
	set pathToJest(commandLine: string);
	/**
	 * Path to a local Jest config file.
	 *
	 * @type {string}
	 */
	pathToConfig: string;
	/**
	 * local Jest major release version, as the runner could run against
	 * any version of Jest.
	 *
	 * @type {number}
	 */
	localJestMajorVersion: number;
	/**
	 * Whether test coverage should be (automatically) collected.
	 *
	 * @type {boolean}
	 */
	collectCoverage?: boolean;
	/**
	 * if to output more information for debugging purpose. Default is false.
	 *
	 * @type {boolean}
	 */
	debug?: boolean;
	/**
	 * suffix string used as part of the output file path, this is to support concurrent Runners.
	 *
	 * @type {string}
	 * @memberof ProjectWorkspace
	 */
	outputFileSuffix?: string;
	/**
	 * optional additional node env variables
	 */
	nodeEnv?: {
		[key: string]: string | undefined;
	};
	/**
	 * optional custom shell for node child_process spawn() call. Default is '/bin/sh' on Unix, and process.env.ComSpec on Windows.
	 * see https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options
	 *
	 * If a string is passed in, a non-login/non-interactive shell will be used to spawn the child_process
	 * If a terminal-shell is passed, a login/interactive shell will be used to spawn the child_process. This is not as efficient as
	 * the non-login/non-interactive shell, but might be needed if parent environment is not guarenteed to be properly initialized
	 * (see https://github.com/jest-community/vscode-jest/issues/741)
	 */
	shell?: string | LoginShell;
	/**
	 * Wether dashed args should be used for the jest command line. Default is false.
	 */
	useDashedArgs?: boolean;
	constructor(rootPath: string, jestCommandLine: string, pathToConfig: string, localJestMajorVersion: number, outputFileSuffix?: string, collectCoverage?: boolean, debug?: boolean, nodeEnv?: {
		[key: string]: string | undefined;
	}, shell?: string | LoginShell, useDashedArgs?: boolean);
}
declare const createProcess: (workspace: ProjectWorkspace, args: string[]) => ChildProcess;
export interface CodeLocation {
	column: number;
	line: number;
}
export type RunArgs = {
	args: string[];
	replace?: boolean;
	skipConversion?: boolean;
};
export type Options = {
	createProcess?: (workspace: ProjectWorkspace, args: string[]) => ChildProcess;
	noColor?: boolean;
	testNamePattern?: string;
	testFileNamePattern?: string;
	reporters?: string[];
	/** either to append or replace the Runner process arguments */
	args?: RunArgs;
};
export declare enum MessageTypes {
	noTests = 1,
	testResults = 3,
	unknown = 0,
	watchUsage = 2
}
export type MessageType = number;
export type RunnerEventMap = {
	processClose: [
		code: number | null,
		signal: string | null
	];
	processExit: [
		code: number | null,
		signal: string | null
	];
	executableJSON: [
		data: object,
		{
			noTestsFound: boolean;
		}
	];
	executableStdErr: [
		data: Buffer,
		{
			type: MessageType;
		}
	];
	executableOutput: [
		data: string
	];
	terminalError: [
		error: string
	];
	debuggerProcessExit: [
	];
};
export type AllRunnerEvent = keyof RunnerEventMap;
export type RunnerEvent = Exclude<AllRunnerEvent, "debuggerProcessExit">;
export declare class Runner extends EventEmitter<RunnerEventMap> {
	watchMode: boolean;
	watchAll: boolean;
	constructor(workspace: ProjectWorkspace, options?: Options);
	start(watchMode?: boolean, watchAll?: boolean): void;
	runJestWithUpdateForSnapshots(completion: () => void, args?: string[]): void;
	closeProcess(): void;
}
export type JestSettings = {
	jestVersionMajor: number;
	configs: Config.ProjectConfig[];
};
export function getSettings(workspace: ProjectWorkspace, options?: Options): Promise<JestSettings>;
/**
 * range and location here are 1-based position.
 */
export declare class ParsedRange {
	start: CodeLocation;
	end: CodeLocation;
	constructor(startLine: number, startCol: number, endLine: number, endCol: number);
}
export declare enum ParsedNodeType {
	describe = "describe",
	expect = "expect",
	it = "it",
	root = "root"
}
export declare class ParsedNode {
	type: ParsedNodeType;
	start?: CodeLocation;
	end?: CodeLocation;
	file: string;
	children?: ParsedNode[];
	constructor(type: ParsedNodeType, file: string);
	addChild(type: ParsedNodeType): ParsedNode;
	filter(f: (node: ParsedNode) => boolean, filterSelf?: boolean): ParsedNode[];
}
export declare class Expect extends ParsedNode {
	constructor(file: string);
}
export declare class NamedBlock extends ParsedNode {
	name: string;
	nameRange?: ParsedRange;
	lastProperty?: string;
	/**
	 * type of the name, it's the babel Node["type"], such as "Literal", "TemplateLiteral" etc
	 *
	 * TODO babel parser currently returns "Literal" for the it/describe name argument, which is not part of its "type" definition, therefore declare a string type for now until it is fixed in babel.
	 * */
	nameType?: string;
	constructor(type: ParsedNodeType, file: string, name?: string);
}
export declare class ItBlock extends NamedBlock {
	constructor(file: string, name?: string);
}
export declare class DescribeBlock extends NamedBlock {
	constructor(file: string, name?: string);
}
export interface IParseResults {
	describeBlocks: DescribeBlock[];
	expects: Expect[];
	itBlocks: ItBlock[];
	root: ParsedNode;
	file: string;
}
declare class ParseResult implements IParseResults {
	describeBlocks: DescribeBlock[];
	expects: Expect[];
	itBlocks: ItBlock[];
	root: ParsedNode;
	file: string;
	constructor(file: string);
	addNode(node: ParsedNode, dedup?: boolean): void;
}
export interface JESParserPluginOptions {
	decorators?: "legacy" | DecoratorsPluginOptions;
}
export interface JESParserOptions {
	plugins?: JESParserPluginOptions;
	strictMode?: boolean;
}
declare const getASTfor: (file: string, data?: string, options?: JESParserOptions) => t.File;
/**
 * parse the test file by selecting proper parser based on the file extension.
 *
 * exception will be throw should the underlying parse failed.
 */
export function parse(filePath: string, serializedData?: string, options?: JESParserOptions): ParseResult;
export type ParserFunc = typeof getASTfor;
export type SnapshotNode = t.Identifier;
export interface SnapshotBlock {
	node: SnapshotNode;
	parents: t.Node[];
}
export interface SnapshotMetadata {
	exists: boolean;
	name: string;
	node: SnapshotNode;
	content?: string;
}
export interface SnapshotParserOptions {
	verbose?: boolean;
	parserOptions?: JESParserOptions;
}
export declare class Snapshot {
	constructor(parser?: ParserFunc, customMatchers?: string[], projectConfig?: Config.ProjectConfig);
	parse(filePath: string, options?: SnapshotParserOptions): SnapshotBlock[];
	/**
	 * look for snapshot content for the given test.
	 * @param {*} filePath
	 * @param {*} name can be a literal string or a regex pattern.
	 * @returns the content of the snapshot, if exist. If name is a string, a string will be returned. If name is a RegExp,
	 * a SnapshotData object will be returned with all matched snapshots. If nothing matched, null will be returned.
	 * @throws throws exception if the snapshot version mismatched or any other unexpected error.
	 */
	getSnapshotContent(filePath: string, name: string | RegExp): Promise<string | utils.SnapshotData | null>;
	getMetadataAsync(filePath: string, options?: SnapshotParserOptions): Promise<SnapshotMetadata[]>;
	getMetadata(filePath: string, options?: SnapshotParserOptions): SnapshotMetadata[];
}
export type JestFileResults = FormattedTestResults["testResults"][number];
export type JestAssertionResults = JestFileResults["assertionResults"][number];
export type JestTotalResults = Omit<FormattedTestResults, "coverageMap"> & {
	coverageMap?: CoverageMapData;
};
/**
 *  Did the thing pass, fail or was it not run?
 */
export type TestReconciliationState = "Unknown" | "KnownFail" | "KnownSuccess" | "KnownSkip" | "KnownTodo";
export type TestAssertionStatus = Omit<JestAssertionResults, "status"> & {
	status: TestReconciliationState;
	message: string;
	shortMessage?: string;
	terseMessage?: string;
	location?: CodeLocation;
	line?: number;
};
export type TestFileAssertionStatus = Omit<JestFileResults, "status" | "assertionResults" | "name"> & {
	file: string;
	status: TestReconciliationState;
	assertions: TestAssertionStatus[] | null;
};
/**
 *  You have a Jest test runner watching for changes, and you have
 *  an extension that wants to know where to show errors after file parsing.
 *
 *  This class represents the state between runs, keeping track of passes/fails
 *  at a file level, generating useful error messages and providing a nice API.
 */
export declare class TestReconciler {
	constructor();
	updateFileWithJestStatus(results: JestTotalResults): TestFileAssertionStatus[];
	/**
	 * remove jest status of the test file from the cached results
	 * @param {string} fileName
	 */
	removeTestFile(fileName: string): void;
	stateForTestFile(file: string): TestReconciliationState;
	assertionsForTestFile(file: string): TestAssertionStatus[] | null;
	stateForTestAssertion(file: string, name: string): TestAssertionStatus | null;
}

declare namespace Process {
	export { createProcess };
}

export {
	Process,
};

export {};
